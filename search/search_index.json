{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to OppoT2 CPU Documentation All documentation regarding the design and use of the CPU is kept here. Assembler Documentation All documentation regarding the design and use of the assembler is kept here.","title":"Home"},{"location":"#welcome-to-oppot2","text":"","title":"Welcome to OppoT2"},{"location":"#cpu-documentation","text":"All documentation regarding the design and use of the CPU is kept here.","title":"CPU Documentation"},{"location":"#assembler-documentation","text":"All documentation regarding the design and use of the assembler is kept here.","title":"Assembler Documentation"},{"location":"asm/","text":"ASM","title":"Assembler Overview"},{"location":"asm/#asm","text":"","title":"ASM"},{"location":"cpu/","text":"CPU This set of documentation describes the ISA of the OppoT2 processor. This processor is derived from the RiSC-16 processor developed by Prof. Bruce Jacob at the University of Maryland. CPU Specifications Sequential Execution Fixed 32-bit data/instruction width Memory Mapped I/O","title":"CPU Overview"},{"location":"cpu/#cpu","text":"This set of documentation describes the ISA of the OppoT2 processor. This processor is derived from the RiSC-16 processor developed by Prof. Bruce Jacob at the University of Maryland.","title":"CPU"},{"location":"cpu/#cpu-specifications","text":"Sequential Execution Fixed 32-bit data/instruction width Memory Mapped I/O","title":"CPU Specifications"},{"location":"cpu/instructions/","text":"Instruction Set Architecture This is a list of all instructions that the CPU supports. Any instruction with the ? suffix is not fully implemented into the CPU. Anytime rA , rB , or rC is seen indicates that a register is being used. imm signifies an immediate value. ADD Adds the two numbers stored in rB and rC , then store the resulting value in rA . Syntax ADD rA, rB, rC Instruction Data Type Data Clock Cycles 4 Source rB , rC Destination rA Instruction Format RRR ADDI Adds the number in rB with the simm17 , then store the resulting value in rA . Syntax ADDI rA, rB, simm17 Instruction Data Type Data Clock Cycles 4 Source rB , imm Destination rA Instruction Format RRI OR Bitwise OR the number in rB and rC , then store the resulting value in rA . Syntax OR rA, rB, rC Instruction Data Type Data Clock Cycles 4 Source rB , rC Destination rA Instruction Format RRR XOR Bitwise XOR the number in rB and rC , then store the resulting value in rA . Syntax XOR rA, rB, rC Instruction Data Type Data Clock Cycles 4 Source rB , rC Destination rA Instruction Format RRR SHLL Shift the number in rB by the least significant bits in rC logically left, then store the resulting value in rA . Syntax SHLL rA, rB, rC Instruction Data Type Data Clock Cycles 4 Source rB , rC Destination rA Instruction Format RRR SHLR Shift the number in rB by the least significant bits in rC logically right, then store the resulting value in rA . Syntax SHLR, rA, rB, rC Instruction Data Type Data Clock Cycles 4 Source rB , rC Destination rA Instruction Format RRR NEG Invert the bits in rB , then store the resulting value in rA . Syntax NEG rA, rB Instruction Data Type Data Clock Cycles 4 Source rB Destination rA Instruction Format RR AND Bitwise AND the number in rB and rC , then store the resulting value in rA . Syntax AND rA, rB, rC Instruction Data Type Data Clock Cycles 4 Source rB , rC Destination rA Instruction Format RRR LW Load a word from memory by adding rB to the simm17 to form the memory address, then store the value into rA . Syntax LW rA, rB, simm17 Instruction Data Type Data Clock Cycles 4 Source rB , imm Destination rA Instruction Format RRI SW Store a word to memory by adding rB to the simm17 to form the memory address, then store the value from rA into memory. Syntax SW rA, rB, simm17 Instruction Data Type Data Clock Cycles 4 Source rB , imm Destination rA Instruction Format RRI BRC Check for a given condition, then jump to the address of the simm13 if true. Syntax BRC rA, rB, COND, simm13 Instruction Data Type Data Clock Cycles 4 Source rB , imm Destination rA Instruction Format RRCI Conditions Integer Value Conditions 0 EQ 1 !EQ 2 GT 3 GTE 4 LT 5 LTE 6 PASS The PASS Conditional is always true, and if chosen will always result in a jump. JALR Store the address of Program Counter + 1 to rA , then jump to the address in rB . Syntax JALR rA, rB Instruction Data Type Data Clock Cycles 4 Source rB Destination rA Instruction Format RR PUSH Push the value of rA to the stack. Syntax PUSH rA Instruction Data Type Data Clock Cycles 4 Source rA Destination sp Instruction Format R POP Pop the value of the stack to rA . Syntax POP rA Instruction Data Type Data Clock Cycles 4 Source sp Destination rA Instruction Format R LUI Store the value of imm15 << 17 to rA . Syntax LUI rA, imm15 Instruction Data Type Data Clock Cycles 4 Source imm Destination rA Instruction Format RI SIRA Upon entering an interrupt service routine, this instruction saves the return address to rA . Syntax SIRA rA Instruction Data Type Data Clock Cycles 4 Source Interrupt Return Address Destination rA Instruction Format R Because interrupts can be chained together, this is a way to save the return address onto the stack. Some ISRs may not be capable of handling out of order input, and should be disabled with the CSRW instruction. INT? Trigger a software interrupt. Syntax INT rA Instruction Data Type Data Clock Cycles 7 Source Destination Instruction Format R Although this instruction is not supported quite yet, it will allow an interrupt to be triggered where rA is the value that the ISR will handle. ORI Bitwise OR the number in rB with simm17 , then store the resulting value in rA . Syntax ORI rA, rB, simm17 Instruction Data Type Data Clock Cycles 4 Source rB , imm Destination rA Instruction Format RRI CSRW Write the value in rA to the Control Status Register Syntax CSRW rA Instruction Data Type Data Clock Cycles 4 Source rA Destination csr Instruction Format RRI CSRR Read the value in the Control Status Register and store in rA Syntax CSRW rA Instruction Data Type Data Clock Cycles 4 Source csr Destination rA Instruction Format RRI","title":"Instructions"},{"location":"cpu/instructions/#instruction-set-architecture","text":"This is a list of all instructions that the CPU supports. Any instruction with the ? suffix is not fully implemented into the CPU. Anytime rA , rB , or rC is seen indicates that a register is being used. imm signifies an immediate value.","title":"Instruction Set Architecture"},{"location":"cpu/instructions/#add","text":"Adds the two numbers stored in rB and rC , then store the resulting value in rA .","title":"ADD"},{"location":"cpu/instructions/#syntax","text":"ADD rA, rB, rC","title":"Syntax"},{"location":"cpu/instructions/#instruction-data","text":"Type Data Clock Cycles 4 Source rB , rC Destination rA Instruction Format RRR","title":"Instruction Data"},{"location":"cpu/instructions/#addi","text":"Adds the number in rB with the simm17 , then store the resulting value in rA .","title":"ADDI"},{"location":"cpu/instructions/#syntax_1","text":"ADDI rA, rB, simm17","title":"Syntax"},{"location":"cpu/instructions/#instruction-data_1","text":"Type Data Clock Cycles 4 Source rB , imm Destination rA Instruction Format RRI","title":"Instruction Data"},{"location":"cpu/instructions/#or","text":"Bitwise OR the number in rB and rC , then store the resulting value in rA .","title":"OR"},{"location":"cpu/instructions/#syntax_2","text":"OR rA, rB, rC","title":"Syntax"},{"location":"cpu/instructions/#instruction-data_2","text":"Type Data Clock Cycles 4 Source rB , rC Destination rA Instruction Format RRR","title":"Instruction Data"},{"location":"cpu/instructions/#xor","text":"Bitwise XOR the number in rB and rC , then store the resulting value in rA .","title":"XOR"},{"location":"cpu/instructions/#syntax_3","text":"XOR rA, rB, rC","title":"Syntax"},{"location":"cpu/instructions/#instruction-data_3","text":"Type Data Clock Cycles 4 Source rB , rC Destination rA Instruction Format RRR","title":"Instruction Data"},{"location":"cpu/instructions/#shll","text":"Shift the number in rB by the least significant bits in rC logically left, then store the resulting value in rA .","title":"SHLL"},{"location":"cpu/instructions/#syntax_4","text":"SHLL rA, rB, rC","title":"Syntax"},{"location":"cpu/instructions/#instruction-data_4","text":"Type Data Clock Cycles 4 Source rB , rC Destination rA Instruction Format RRR","title":"Instruction Data"},{"location":"cpu/instructions/#shlr","text":"Shift the number in rB by the least significant bits in rC logically right, then store the resulting value in rA .","title":"SHLR"},{"location":"cpu/instructions/#syntax_5","text":"SHLR, rA, rB, rC","title":"Syntax"},{"location":"cpu/instructions/#instruction-data_5","text":"Type Data Clock Cycles 4 Source rB , rC Destination rA Instruction Format RRR","title":"Instruction Data"},{"location":"cpu/instructions/#neg","text":"Invert the bits in rB , then store the resulting value in rA .","title":"NEG"},{"location":"cpu/instructions/#syntax_6","text":"NEG rA, rB","title":"Syntax"},{"location":"cpu/instructions/#instruction-data_6","text":"Type Data Clock Cycles 4 Source rB Destination rA Instruction Format RR","title":"Instruction Data"},{"location":"cpu/instructions/#and","text":"Bitwise AND the number in rB and rC , then store the resulting value in rA .","title":"AND"},{"location":"cpu/instructions/#syntax_7","text":"AND rA, rB, rC","title":"Syntax"},{"location":"cpu/instructions/#instruction-data_7","text":"Type Data Clock Cycles 4 Source rB , rC Destination rA Instruction Format RRR","title":"Instruction Data"},{"location":"cpu/instructions/#lw","text":"Load a word from memory by adding rB to the simm17 to form the memory address, then store the value into rA .","title":"LW"},{"location":"cpu/instructions/#syntax_8","text":"LW rA, rB, simm17","title":"Syntax"},{"location":"cpu/instructions/#instruction-data_8","text":"Type Data Clock Cycles 4 Source rB , imm Destination rA Instruction Format RRI","title":"Instruction Data"},{"location":"cpu/instructions/#sw","text":"Store a word to memory by adding rB to the simm17 to form the memory address, then store the value from rA into memory.","title":"SW"},{"location":"cpu/instructions/#syntax_9","text":"SW rA, rB, simm17","title":"Syntax"},{"location":"cpu/instructions/#instruction-data_9","text":"Type Data Clock Cycles 4 Source rB , imm Destination rA Instruction Format RRI","title":"Instruction Data"},{"location":"cpu/instructions/#brc","text":"Check for a given condition, then jump to the address of the simm13 if true.","title":"BRC"},{"location":"cpu/instructions/#syntax_10","text":"BRC rA, rB, COND, simm13","title":"Syntax"},{"location":"cpu/instructions/#instruction-data_10","text":"Type Data Clock Cycles 4 Source rB , imm Destination rA Instruction Format RRCI","title":"Instruction Data"},{"location":"cpu/instructions/#conditions","text":"Integer Value Conditions 0 EQ 1 !EQ 2 GT 3 GTE 4 LT 5 LTE 6 PASS The PASS Conditional is always true, and if chosen will always result in a jump.","title":"Conditions"},{"location":"cpu/instructions/#jalr","text":"Store the address of Program Counter + 1 to rA , then jump to the address in rB .","title":"JALR"},{"location":"cpu/instructions/#syntax_11","text":"JALR rA, rB","title":"Syntax"},{"location":"cpu/instructions/#instruction-data_11","text":"Type Data Clock Cycles 4 Source rB Destination rA Instruction Format RR","title":"Instruction Data"},{"location":"cpu/instructions/#push","text":"Push the value of rA to the stack.","title":"PUSH"},{"location":"cpu/instructions/#syntax_12","text":"PUSH rA","title":"Syntax"},{"location":"cpu/instructions/#instruction-data_12","text":"Type Data Clock Cycles 4 Source rA Destination sp Instruction Format R","title":"Instruction Data"},{"location":"cpu/instructions/#pop","text":"Pop the value of the stack to rA .","title":"POP"},{"location":"cpu/instructions/#syntax_13","text":"POP rA","title":"Syntax"},{"location":"cpu/instructions/#instruction-data_13","text":"Type Data Clock Cycles 4 Source sp Destination rA Instruction Format R","title":"Instruction Data"},{"location":"cpu/instructions/#lui","text":"Store the value of imm15 << 17 to rA .","title":"LUI"},{"location":"cpu/instructions/#syntax_14","text":"LUI rA, imm15","title":"Syntax"},{"location":"cpu/instructions/#instruction-data_14","text":"Type Data Clock Cycles 4 Source imm Destination rA Instruction Format RI","title":"Instruction Data"},{"location":"cpu/instructions/#sira","text":"Upon entering an interrupt service routine, this instruction saves the return address to rA .","title":"SIRA"},{"location":"cpu/instructions/#syntax_15","text":"SIRA rA","title":"Syntax"},{"location":"cpu/instructions/#instruction-data_15","text":"Type Data Clock Cycles 4 Source Interrupt Return Address Destination rA Instruction Format R Because interrupts can be chained together, this is a way to save the return address onto the stack. Some ISRs may not be capable of handling out of order input, and should be disabled with the CSRW instruction.","title":"Instruction Data"},{"location":"cpu/instructions/#int","text":"Trigger a software interrupt.","title":"INT?"},{"location":"cpu/instructions/#syntax_16","text":"INT rA","title":"Syntax"},{"location":"cpu/instructions/#instruction-data_16","text":"Type Data Clock Cycles 7 Source Destination Instruction Format R Although this instruction is not supported quite yet, it will allow an interrupt to be triggered where rA is the value that the ISR will handle.","title":"Instruction Data"},{"location":"cpu/instructions/#ori","text":"Bitwise OR the number in rB with simm17 , then store the resulting value in rA .","title":"ORI"},{"location":"cpu/instructions/#syntax_17","text":"ORI rA, rB, simm17","title":"Syntax"},{"location":"cpu/instructions/#instruction-data_17","text":"Type Data Clock Cycles 4 Source rB , imm Destination rA Instruction Format RRI","title":"Instruction Data"},{"location":"cpu/instructions/#csrw","text":"Write the value in rA to the Control Status Register","title":"CSRW"},{"location":"cpu/instructions/#syntax_18","text":"CSRW rA","title":"Syntax"},{"location":"cpu/instructions/#instruction-data_18","text":"Type Data Clock Cycles 4 Source rA Destination csr Instruction Format RRI","title":"Instruction Data"},{"location":"cpu/instructions/#csrr","text":"Read the value in the Control Status Register and store in rA","title":"CSRR"},{"location":"cpu/instructions/#syntax_19","text":"CSRW rA","title":"Syntax"},{"location":"cpu/instructions/#instruction-data_19","text":"Type Data Clock Cycles 4 Source csr Destination rA Instruction Format RRI","title":"Instruction Data"},{"location":"cpu/isa/","text":"Instructions Type Instruction Syntax Type Function ALU ADD ADD rA, rB, rC RRR rA <- rB + rC ADDI ADDI rA, rB, simm17 RRI rA <- rB + simm17 OR OR rA, rB, rC RRR rA <- rB | rC XOR XOR rA, rB, rC RRR rA <- rB ^ rC SHLL SHLL rA, rB, rC RRR rA <- rB << rC SHLR SHLR, rA, rB, rC RRR rA <- rB >> rC NEG NEG rA, rB RR rA <- ~rB AND AND rA, rB, rC RRR rA <- rB & rC Memory LW LW rA, rB, simm17 RRI R[regA] <- Mem[ R[regB] + immed ] SW SW rA, rB, simm17 RRI R[regA] -> Mem[ R[regB] + immed ] Jumps BRC BRC rA, rB, COND, simm13 RRCI if (rA compares rB) jmp JALR JALR rA, rB RR rA <- PC + 1 && PC <- rB Stack PUSH PUSH rA R stack <- rA POP POP rA R rA <- stack Immediate LUI LUI rA, imm15 RI rA <- imm15 << 17 Interrupt SIRA SIRA rA RR rA <- Int Return Address INT? INT, rA, simm17 Trigger a software interrupt ORI ORI, rA, rB, simm17 RRI rA <- rB | imm17 Control Status CSRW CSRW rA R rA -> CSR CSRR CSRR rA R rA <- CSR","title":"ISA Design"},{"location":"cpu/isa/#instructions","text":"Type Instruction Syntax Type Function ALU ADD ADD rA, rB, rC RRR rA <- rB + rC ADDI ADDI rA, rB, simm17 RRI rA <- rB + simm17 OR OR rA, rB, rC RRR rA <- rB | rC XOR XOR rA, rB, rC RRR rA <- rB ^ rC SHLL SHLL rA, rB, rC RRR rA <- rB << rC SHLR SHLR, rA, rB, rC RRR rA <- rB >> rC NEG NEG rA, rB RR rA <- ~rB AND AND rA, rB, rC RRR rA <- rB & rC Memory LW LW rA, rB, simm17 RRI R[regA] <- Mem[ R[regB] + immed ] SW SW rA, rB, simm17 RRI R[regA] -> Mem[ R[regB] + immed ] Jumps BRC BRC rA, rB, COND, simm13 RRCI if (rA compares rB) jmp JALR JALR rA, rB RR rA <- PC + 1 && PC <- rB Stack PUSH PUSH rA R stack <- rA POP POP rA R rA <- stack Immediate LUI LUI rA, imm15 RI rA <- imm15 << 17 Interrupt SIRA SIRA rA RR rA <- Int Return Address INT? INT, rA, simm17 Trigger a software interrupt ORI ORI, rA, rB, simm17 RRI rA <- rB | imm17 Control Status CSRW CSRW rA R rA -> CSR CSRR CSRR rA R rA <- CSR","title":"Instructions"}]}