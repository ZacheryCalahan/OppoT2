{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to OppoT2","text":""},{"location":"#cpu-documentation","title":"CPU Documentation","text":"<p>All documentation regarding the design and use of the CPU is kept here.</p>"},{"location":"#assembler-documentation","title":"Assembler Documentation","text":"<p>All documentation regarding the design and use of the assembler is kept here.</p>"},{"location":"asm/","title":"ASM","text":""},{"location":"cpu/","title":"CPU","text":"<p>This set of documentation describes the ISA of the OppoT2 processor. This processor is derived from the RiSC-16 processor developed by Prof. Bruce Jacob at the University of Maryland.</p>"},{"location":"cpu/#cpu-specifications","title":"CPU Specifications","text":"<ul> <li>Sequential Execution </li> <li>Fixed 32-bit data/instruction width</li> <li>Memory Mapped I/O</li> </ul>"},{"location":"cpu/conventions/","title":"CPU Conventions","text":"<p>This CPU has been designed to used in various different ways, but the conventions will allow developers to keep track of the CPU state.</p>"},{"location":"cpu/conventions/#registers","title":"Registers","text":"<p>The registers are of a similar design to the RISC-V processor, but are organized differently. The names of the registers should be used to refer to a register within the assembler, but the assembler can also accept the register's integer representation. </p> <p>The registers that the CPU keeps track of are in two different groups, the general purpose registers and the special registers. </p>"},{"location":"cpu/conventions/#general-purpose-registers","title":"General Purpose Registers","text":"<p>These registers can be used in any instruction that handles registers specifically. Each register's use is only by convention, and other than <code>r0</code> are not handled by the CPU in any special way. </p> <p>Register Safety</p> <p>A developer can write a return address of a subroutine to the stack pointer without issue from the CPU if that is really what the developer wants. It is heavily recommended that a user uses the register names to avoid such bugs.</p> Register Integer Register Name Usage Saved by calle- 0 <code>r0</code> Hardwired Zero 1 <code>ra</code> Return Address -R 2 <code>s0</code> Saved Register -E 3 <code>s1</code> Saved Register -E 4 <code>s2</code> Saved Register -E 5 <code>s3</code> Saved Register -E 6 <code>s4</code> Saved Register -E 7 <code>s5</code> Saved Register -E 8 <code>s6</code> Saved Register -E 9 <code>s7</code> Saved Register -E 10 <code>t0</code> Temp Register -R 11 <code>t1</code> Temp Register -R 12 <code>t2</code> Temp Register -R 13 <code>t3</code> Temp Register -R 14 <code>t4</code> Temp Register -R 15 <code>t5</code> Temp Register -R 16 <code>t6</code> Temp Register -R 17 <code>t7</code> Temp Register -R 18 <code>r18</code> Function Argument 0 -E 19 <code>r19</code> Function Argument 1 -E 20 <code>r20</code> Function Argument 2 -E 21 <code>r21</code> Function Argument 3 -E 22 <code>r22</code> Function Return -E 23 <code>r23</code> 24 <code>r24</code> 25 <code>r25</code> 26 <code>r26</code> 27 <code>r27</code> 28 <code>r28</code> 29 <code>r29</code> Long Jump Register 30 <code>isr</code> Interrupt Status Reg -E 31 <code>r31</code> Stack Pointer"},{"location":"cpu/conventions/#special-registers","title":"Special Registers","text":"<p>Some registers do not live within the Register File, and are only accessable through special instructions. These are listed here.</p> Register Name Use Accessable? <code>pc</code> Program Counter Yes BRC <code>csr</code> Return Address Yes CSRW <code>iret</code> Return Address Read-Only SIRA"},{"location":"cpu/conventions/#memory","title":"Memory","text":"<p>Generally the memory map can be entirely chosen by the developer, but a few memory locations are hardcoded. These exceptions are listed below.</p> Memory Location Use Description 0x00000000 Boot Location Location CPU starts execution at. 0x00002FFF Interrupt Service Routine Vector Location of where CPU jumps to when an interrupt is raised. <p>Because the boot code could possibly be larger than 12287 words, the start of the ISR vector, it is recommended that a memory address is jumped to directly after gaining control of the CPU. Example (Kernel location 0x00004fff):</p> <pre><code>    movi r29, 0x00004ffff   # Load kernel location\n    jalr r0, r29            # Long Jump to kernel\n</code></pre> <p>Note</p> <p>MOVI is a psuedo-op, and uses two instructions to load a 32-bit value into a register.</p> <p>This is an example of the maximum needed words to jump to any location in memory, which requires 3 words. Since there are 12287 words before the start of the next reserved location in memory, this area is suitable for BIOS style ROM as well.</p>"},{"location":"cpu/instructions/","title":"Opcodes","text":"<p>This is a list of all instructions that the CPU supports. Any instruction with the <code>?</code> suffix is not fully implemented into the CPU.</p> <p>Anytime <code>rA</code>, <code>rB</code>, or <code>rC</code> is seen indicates that a register is being used. <code>imm</code> signifies an immediate value, with the number following <code>imm</code> signifying the bit width.</p>"},{"location":"cpu/instructions/#add","title":"ADD","text":"<p>Adds the two numbers stored in <code>rB</code> and <code>rC</code>, then store the resulting value in <code>rA</code>.</p>"},{"location":"cpu/instructions/#syntax","title":"Syntax","text":"<p><code>ADD rA, rB, rC</code></p>"},{"location":"cpu/instructions/#instruction-data","title":"Instruction Data","text":"Type Data Clock Cycles 4 Source <code>rB</code>, <code>rC</code> Destination <code>rA</code> Instruction Format RRR"},{"location":"cpu/instructions/#addi","title":"ADDI","text":"<p>Adds the number in <code>rB</code> with the <code>simm17</code>, then store the resulting value in <code>rA</code>.</p>"},{"location":"cpu/instructions/#syntax_1","title":"Syntax","text":"<p><code>ADDI rA, rB, simm17</code></p>"},{"location":"cpu/instructions/#instruction-data_1","title":"Instruction Data","text":"Type Data Clock Cycles 4 Source <code>rB</code>, <code>imm</code> Destination <code>rA</code> Instruction Format RRI"},{"location":"cpu/instructions/#or","title":"OR","text":"<p>Bitwise OR the number in <code>rB</code> and <code>rC</code>, then store the resulting value in <code>rA</code>.</p>"},{"location":"cpu/instructions/#syntax_2","title":"Syntax","text":"<p><code>OR rA, rB, rC</code></p>"},{"location":"cpu/instructions/#instruction-data_2","title":"Instruction Data","text":"Type Data Clock Cycles 4 Source <code>rB</code>, <code>rC</code> Destination <code>rA</code> Instruction Format RRR"},{"location":"cpu/instructions/#xor","title":"XOR","text":"<p>Bitwise XOR the number in <code>rB</code> and <code>rC</code>, then store the resulting value in <code>rA</code>.</p>"},{"location":"cpu/instructions/#syntax_3","title":"Syntax","text":"<p><code>XOR rA, rB, rC</code></p>"},{"location":"cpu/instructions/#instruction-data_3","title":"Instruction Data","text":"Type Data Clock Cycles 4 Source <code>rB</code>, <code>rC</code> Destination <code>rA</code> Instruction Format RRR"},{"location":"cpu/instructions/#shll","title":"SHLL","text":"<p>Shift the number in <code>rB</code> by the least significant bits in <code>rC</code> logically left, then store the resulting value in <code>rA</code>.</p>"},{"location":"cpu/instructions/#syntax_4","title":"Syntax","text":"<p><code>SHLL rA, rB, rC</code></p>"},{"location":"cpu/instructions/#instruction-data_4","title":"Instruction Data","text":"Type Data Clock Cycles 4 Source <code>rB</code>, <code>rC</code> Destination <code>rA</code> Instruction Format RRR"},{"location":"cpu/instructions/#shlr","title":"SHLR","text":"<p>Shift the number in <code>rB</code> by the least significant bits in <code>rC</code> logically right, then store the resulting value in <code>rA</code>.</p>"},{"location":"cpu/instructions/#syntax_5","title":"Syntax","text":"<p><code>SHLR, rA, rB, rC</code></p>"},{"location":"cpu/instructions/#instruction-data_5","title":"Instruction Data","text":"Type Data Clock Cycles 4 Source <code>rB</code>, <code>rC</code> Destination <code>rA</code> Instruction Format RRR"},{"location":"cpu/instructions/#neg","title":"NEG","text":"<p>Invert the bits in <code>rB</code>, then store the resulting value in <code>rA</code>.</p>"},{"location":"cpu/instructions/#syntax_6","title":"Syntax","text":"<p><code>NEG rA, rB</code></p>"},{"location":"cpu/instructions/#instruction-data_6","title":"Instruction Data","text":"Type Data Clock Cycles 4 Source <code>rB</code> Destination <code>rA</code> Instruction Format RR"},{"location":"cpu/instructions/#and","title":"AND","text":"<p>Bitwise AND the number in <code>rB</code> and <code>rC</code>, then store the resulting value in <code>rA</code>.</p>"},{"location":"cpu/instructions/#syntax_7","title":"Syntax","text":"<p><code>AND rA, rB, rC</code></p>"},{"location":"cpu/instructions/#instruction-data_7","title":"Instruction Data","text":"Type Data Clock Cycles 4 Source <code>rB</code>, <code>rC</code> Destination <code>rA</code> Instruction Format RRR"},{"location":"cpu/instructions/#lw","title":"LW","text":"<p>Load a word from memory by adding <code>rB</code> to the <code>simm17</code> to form the memory address, then store the value into <code>rA</code>.</p>"},{"location":"cpu/instructions/#syntax_8","title":"Syntax","text":"<p><code>LW rA, rB, simm17</code></p>"},{"location":"cpu/instructions/#instruction-data_8","title":"Instruction Data","text":"Type Data Clock Cycles 4 Source <code>rB</code>, <code>imm</code> Destination <code>rA</code> Instruction Format RRI"},{"location":"cpu/instructions/#sw","title":"SW","text":"<p>Store a word to memory by adding <code>rB</code> to the <code>simm17</code> to form the memory address, then store the value from <code>rA</code> into memory.</p>"},{"location":"cpu/instructions/#syntax_9","title":"Syntax","text":"<p><code>SW rA, rB, simm17</code></p>"},{"location":"cpu/instructions/#instruction-data_9","title":"Instruction Data","text":"Type Data Clock Cycles 4 Source <code>rB</code>, <code>imm</code> Destination <code>rA</code> Instruction Format RRI"},{"location":"cpu/instructions/#brc","title":"BRC","text":"<p>Check for a given condition, then jump to the address of the <code>simm13</code> if true.</p>"},{"location":"cpu/instructions/#syntax_10","title":"Syntax","text":"<p><code>BRC rA, rB, COND, simm13</code></p>"},{"location":"cpu/instructions/#instruction-data_10","title":"Instruction Data","text":"Type Data Clock Cycles 4 Source <code>rB</code>, <code>imm</code> Destination <code>rA</code> Instruction Format RRCI"},{"location":"cpu/instructions/#conditions","title":"Conditions","text":"Integer Value Conditions 0 <code>EQ</code> 1 <code>!EQ</code> 2 <code>GT</code> 3 <code>GTE</code> 4 <code>LT</code> 5 <code>LTE</code> 6 <code>PASS</code> <p>The <code>PASS</code> Conditional is always true, and if chosen will always result in a jump.</p>"},{"location":"cpu/instructions/#jalr","title":"JALR","text":"<p>Store the address of <code>Program Counter + 1</code> to <code>rA</code>, then jump to the address in <code>rB</code>.</p>"},{"location":"cpu/instructions/#syntax_11","title":"Syntax","text":"<p><code>JALR rA, rB</code></p>"},{"location":"cpu/instructions/#instruction-data_11","title":"Instruction Data","text":"Type Data Clock Cycles 4 Source <code>rB</code> Destination <code>rA</code> Instruction Format RR"},{"location":"cpu/instructions/#push","title":"PUSH","text":"<p>Push the value of <code>rA</code> to the stack.</p>"},{"location":"cpu/instructions/#syntax_12","title":"Syntax","text":"<p><code>PUSH rA</code></p>"},{"location":"cpu/instructions/#instruction-data_12","title":"Instruction Data","text":"Type Data Clock Cycles 4 Source <code>rA</code> Destination <code>sp</code> Instruction Format R"},{"location":"cpu/instructions/#pop","title":"POP","text":"<p>Pop the value of the stack to <code>rA</code>.</p>"},{"location":"cpu/instructions/#syntax_13","title":"Syntax","text":"<p><code>POP rA</code></p>"},{"location":"cpu/instructions/#instruction-data_13","title":"Instruction Data","text":"Type Data Clock Cycles 4 Source <code>sp</code> Destination <code>rA</code> Instruction Format R"},{"location":"cpu/instructions/#lui","title":"LUI","text":"<p>Store the value of <code>imm15</code> &lt;&lt; 17 to <code>rA</code>.</p>"},{"location":"cpu/instructions/#syntax_14","title":"Syntax","text":"<p><code>LUI rA, imm15</code></p>"},{"location":"cpu/instructions/#instruction-data_14","title":"Instruction Data","text":"Type Data Clock Cycles 4 Source <code>imm</code> Destination <code>rA</code> Instruction Format RI"},{"location":"cpu/instructions/#sira","title":"SIRA","text":"<p>Upon entering an interrupt service routine, this instruction saves the return address to <code>rA</code>.</p>"},{"location":"cpu/instructions/#syntax_15","title":"Syntax","text":"<p><code>SIRA rA</code></p>"},{"location":"cpu/instructions/#instruction-data_15","title":"Instruction Data","text":"Type Data Clock Cycles 4 Source Interrupt Return Address Destination <code>rA</code> Instruction Format R <p>Because interrupts can be chained together, this is a way to save the return address onto the stack. Some ISRs may not be capable of handling out of order input, and should be disabled with the CSRW instruction.</p>"},{"location":"cpu/instructions/#int","title":"INT","text":"<p>Trigger a software interrupt. (Not yet implemented into the CPU.)</p>"},{"location":"cpu/instructions/#syntax_16","title":"Syntax","text":"<p><code>INT rA</code></p>"},{"location":"cpu/instructions/#instruction-data_16","title":"Instruction Data","text":"Type Data Clock Cycles 7 Source Destination Instruction Format R <p>Although this instruction is not supported quite yet, it will allow an interrupt to be triggered where <code>rA</code> is the value that the ISR will handle.</p>"},{"location":"cpu/instructions/#ori","title":"ORI","text":"<p>Bitwise OR the number in <code>rB</code> with <code>simm17</code>, then store the resulting value in <code>rA</code>.</p>"},{"location":"cpu/instructions/#syntax_17","title":"Syntax","text":"<p><code>ORI rA, rB, simm17</code></p>"},{"location":"cpu/instructions/#instruction-data_17","title":"Instruction Data","text":"Type Data Clock Cycles 4 Source <code>rB</code>, <code>imm</code> Destination <code>rA</code> Instruction Format RRI"},{"location":"cpu/instructions/#csrw","title":"CSRW","text":"<p>Write the value in <code>rA</code> to the <code>Control Status Register</code></p>"},{"location":"cpu/instructions/#syntax_18","title":"Syntax","text":"<p><code>CSRW rA</code></p>"},{"location":"cpu/instructions/#instruction-data_18","title":"Instruction Data","text":"Type Data Clock Cycles 4 Source <code>rA</code> Destination <code>csr</code> Instruction Format RRI"},{"location":"cpu/instructions/#csrr","title":"CSRR","text":"<p>Read the value in the <code>Control Status Register</code> and store in <code>rA</code></p>"},{"location":"cpu/instructions/#syntax_19","title":"Syntax","text":"<p><code>CSRW rA</code></p>"},{"location":"cpu/instructions/#instruction-data_19","title":"Instruction Data","text":"Type Data Clock Cycles 4 Source <code>csr</code> Destination <code>rA</code> Instruction Format RRI"},{"location":"cpu/instructions/#psuedo-opcodes","title":"Psuedo Opcodes","text":"<p>The assembler supports extra psuedo opcodes, which simplify code writing. These are combinations of other instructions.</p>"},{"location":"cpu/instructions/#movi","title":"MOVI","text":"<p>Move a 32-bit immediate value to a register.</p>"},{"location":"cpu/instructions/#syntax_20","title":"Syntax","text":"<p><code>MOVI rA, imm32</code></p>"},{"location":"cpu/instructions/#instruction-data_20","title":"Instruction Data","text":"Type Data Clock Cycles 8 Source <code>imm32</code> Destination <code>rA</code> <p>This uses the <code>ori</code> and <code>lui</code> opcodes to move a value in two instructions.</p> <pre><code>    lui rA, (imm32 &amp; 0xFFFE0000)\n    ori rA, (imm32 &amp; 0x0001FFFF)\n</code></pre>"},{"location":"cpu/isa/","title":"Instruction Set Overview","text":"Type Instruction Syntax Type Function ALU ADD ADD rA, rB, rC RRR rA &lt;- rB + rC ADDI ADDI rA, rB, simm17 RRI rA &lt;- rB + simm17 OR OR rA, rB, rC RRR rA &lt;- rB | rC XOR XOR rA, rB, rC RRR rA &lt;- rB ^ rC SHLL SHLL rA, rB, rC RRR rA &lt;- rB &lt;&lt; rC SHLR SHLR, rA, rB, rC RRR rA &lt;- rB &gt;&gt; rC NEG NEG rA, rB RR rA &lt;- ~rB AND AND rA, rB, rC RRR rA &lt;- rB &amp; rC Memory LW LW rA, rB, simm17 RRI R[regA] &lt;- Mem[ R[regB] + immed ] SW SW rA, rB, simm17 RRI R[regA] -&gt; Mem[ R[regB] + immed ] Jumps BRC BRC rA, rB, COND, simm13 RRCI if (rA compares rB) jmp JALR JALR rA, rB RR rA &lt;- PC + 1 &amp;&amp; PC &lt;- rB Stack PUSH PUSH rA R stack &lt;- rA POP POP rA R rA &lt;- stack Immediate LUI LUI rA, imm15 RI rA &lt;- imm15 &lt;&lt; 17 Interrupt SIRA SIRA rA RR rA &lt;- Int Return Address INT? INT, rA, simm17 Trigger a software interrupt ORI ORI, rA, rB, simm17 RRI rA &lt;- rB | imm17 Control Status CSRW CSRW rA R rA -&gt; CSR CSRR CSRR rA R rA &lt;- CSR"}]}