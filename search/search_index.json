{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to OppoT2 CPU Documentation All documentation regarding the design and use of the CPU is kept here. Assembler Documentation All documentation regarding the design and use of the assembler is kept here.","title":"Home"},{"location":"#welcome-to-oppot2","text":"","title":"Welcome to OppoT2"},{"location":"#cpu-documentation","text":"All documentation regarding the design and use of the CPU is kept here.","title":"CPU Documentation"},{"location":"#assembler-documentation","text":"All documentation regarding the design and use of the assembler is kept here.","title":"Assembler Documentation"},{"location":"asm/","text":"ASM","title":"Assembler Overview"},{"location":"asm/#asm","text":"","title":"ASM"},{"location":"cpu/","text":"CPU This set of documentation describes the ISA of the OppoT2 processor. This processor is derived from the RiSC-16 processor developed by Prof. Bruce Jacob at the University of Maryland. CPU Specifications Sequential Execution Fixed 32-bit data/instruction width Memory Mapped I/O","title":"CPU Overview"},{"location":"cpu/#cpu","text":"This set of documentation describes the ISA of the OppoT2 processor. This processor is derived from the RiSC-16 processor developed by Prof. Bruce Jacob at the University of Maryland.","title":"CPU"},{"location":"cpu/#cpu-specifications","text":"Sequential Execution Fixed 32-bit data/instruction width Memory Mapped I/O","title":"CPU Specifications"},{"location":"cpu/isa/","text":"Instructions Type Instruction Syntax Type Function ALU ADD ADD rA, rB, rC RRR rA <- rB + rC ADDI ADDI rA, rB, simm17 RRI rA <- rB + simm17 OR OR rA, rB, rC RRR rA <- rB | rC XOR XOR rA, rB, rC RRR rA <- rB ^ rC SHLL SHLL rA, rB, rC RRR rA <- rB << rC SHLR SHLR, rA, rB, rC RRR rA <- rB >> rC NEG NEG rA, rB RR rA <- ~rB AND AND rA, rB, rC RRR rA <- rB & rC Memory LW LW rA, rB, simm17 RRI R[regA] <- Mem[ R[regB] + immed ] SW SW rA, rB, simm17 RRI R[regA] -> Mem[ R[regB] + immed ] Jumps BRC BRC rA, rB, COND, simm13 RRCI if (rA compares rB) jmp JALR JALR rA, rB RR rA <- PC + 1 && PC <- rB Stack PUSH PUSH rA R stack <- rA POP POP rA R rA <- stack Immediate LUI LUI rA, imm15 RI rA <- imm15 << 17 Interrupt SIRA SIRA rA RR rA <- Int Return Address INT? INT, rA, simm17 Trigger a software interrupt ORI ORI, rA, rB, simm17 RRI rA <- rB | imm17 Control Status CSRW CSRW rA R rA -> CSR CSRR CSRR rA R rA <- CSR","title":"ISA Design"},{"location":"cpu/isa/#instructions","text":"Type Instruction Syntax Type Function ALU ADD ADD rA, rB, rC RRR rA <- rB + rC ADDI ADDI rA, rB, simm17 RRI rA <- rB + simm17 OR OR rA, rB, rC RRR rA <- rB | rC XOR XOR rA, rB, rC RRR rA <- rB ^ rC SHLL SHLL rA, rB, rC RRR rA <- rB << rC SHLR SHLR, rA, rB, rC RRR rA <- rB >> rC NEG NEG rA, rB RR rA <- ~rB AND AND rA, rB, rC RRR rA <- rB & rC Memory LW LW rA, rB, simm17 RRI R[regA] <- Mem[ R[regB] + immed ] SW SW rA, rB, simm17 RRI R[regA] -> Mem[ R[regB] + immed ] Jumps BRC BRC rA, rB, COND, simm13 RRCI if (rA compares rB) jmp JALR JALR rA, rB RR rA <- PC + 1 && PC <- rB Stack PUSH PUSH rA R stack <- rA POP POP rA R rA <- stack Immediate LUI LUI rA, imm15 RI rA <- imm15 << 17 Interrupt SIRA SIRA rA RR rA <- Int Return Address INT? INT, rA, simm17 Trigger a software interrupt ORI ORI, rA, rB, simm17 RRI rA <- rB | imm17 Control Status CSRW CSRW rA R rA -> CSR CSRR CSRR rA R rA <- CSR","title":"Instructions"}]}